# Planejamento Completo do Framework de Agentes

## 1. Visão Geral e Objetivos

Arquitetura Otimizada para Depuração: Reconhecendo a natureza falível dos LLMs, o framework é projetado para contenção de falhas. As responsabilidades são rigorosamente isoladas para que o diagnóstico de erros de lógica seja um processo de análise de um sub-agente específico, facilitando a depuração e a manutenção por operadores humanos.

**Pilares Fundamentais:**

*   **Estado via HTTP:** O estado de cada fluxo de trabalho dos agentes será gerenciado e consultável através de uma API HTTP RESTful, tornando o sistema agnóstico a clientes.
*   **Comunicação com SSE:** Para atualizações em tempo real do progresso das tarefas, o framework utilizará Server-Sent Events (SSE), uma alternativa mais simples e leve que WebSockets para comunicação unidirecional do servidor para o cliente.
*   **Independência de SDKs:** As integrações com serviços de LLM (inicialmente OpenAI e OpenRouter) serão feitas através de requisições HTTP diretas com `axios`, evitando o acoplamento com bibliotecas de terceiros como `openai-node` ou `liteLLM`.
*   **Arquitetura Orientada a Princípios:** O design seguirá rigorosamente os princípios SOLID e aplicará padrões de projeto estratégicos para garantir que o framework seja extensível, manutenível e testável.

**Diferenciais em Relação a Concorrentes (Langgraph, CrewAI):**

*   Foco em uma arquitetura de comunicação desacoplada (HTTP/SSE) que facilita a integração com qualquer tipo de cliente.
*   Uma adesão dogmática ao Princípio Aberto/Fechado, permitindo a extensão do framework (novos agentes, LLMs, ferramentas) sem nunca modificar seu código central.

## 2. Arquitetura Geral em Camadas

A aplicação será dividida em camadas lógicas para garantir a separação de responsabilidades e o baixo acoplamento.

1.  **Camada de Entrada (Entrypoints):** Responsável exclusivamente por interagir com o mundo externo. Recebe requisições HTTP, extrai os dados necessários e delega a ação para a camada de orquestração.
2.  **Camada de Orquestração (Orchestration):** O cérebro do framework. Utiliza o padrão **Facade** para fornecer uma interface simples e unificada para a lógica de negócio complexa de iniciar, monitorar e gerenciar os fluxos de trabalho dos agentes. Ele Atua como o executor-chefe do framework. Sua responsabilidade não é raciocinar, mas sim executar um plano de tarefas pré-definido. Utiliza a AgentFactory para delegar cada etapa do plano a um sub-agente especializado e gerencia o fluxo de dados entre eles.
3.  **Camada de Agentes (Agents):** Contém a lógica de negócios dos agentes individuais. Cada agente é tratado como uma **Strategy** intercambiável, permitindo que o orquestrador os utilize de forma polimórfica. Nele contém a lógica de negócio dos agentes, que são divididos em tipos:
- Agentes de Planejamento (PlannerAgent): Responsáveis pelo raciocínio de alto nível, criando o plano de execução.
- Agentes de Execução (ResearcherAgent, etc.): Especialistas focados em executar uma única tarefa do plano, operando com sua própria memória tática de curto prazo.
4.  **Camada de Ferramentas e Infraestrutura (Infrastructure & Tools):** Implementa as interações com sistemas externos. Isso inclui a comunicação com APIs de LLMs e a execução de ferramentas. O padrão **Adapter** é crucial aqui para isolar o núcleo do framework dos detalhes de implementação de serviços de terceiros.
5.  **Camada de Estado e Comunicação (State & Communication):** Gerencia o ciclo de vida e o estado persistente das execuções usando o padrão **State**, e notifica os clientes sobre as mudanças através do gerenciador de SSE.

## 3. Detalhamento dos Módulos e Padrões de Projeto

**Gerenciamento do Fluxo de Trabalho (Facade Pattern)**

* Haverá uma classe central AgentOrchestratorFacade. Ela será o único ponto de contato para a camada de entrada. Seus métodos, como executeWorkflow(prompt), esconderão toda a complexidade interna de criar agentes, gerenciar estados e coordenar tarefas.
* Ciclo de Execução Dinâmico e Replanejamento: O processo não é estritamente linear. O orquestrador atua como um "gerente de projetos" inteligente que reage a imprevistos, transformando o fluxo em um ciclo dinâmico de Planejar -> Executar -> Avaliar -> Replanejar.
    1. O processo é iniciado com uma chamada a um PlannerAgent, que retorna um objeto de Plano estruturado.
    2. O Orquestrador itera sobre este plano, executando cada tarefa sequencialmente.
    3. Ponto Crítico de Avaliação: Após cada tarefa, o Orquestrador analisa o TaskResult retornado. Se o resultado indicar uma falha, um resultado inesperado, ou que a informação obtida invalida os passos futuros do plano, o Orquestrador pode invocar novamente o PlannerAgent.
    4. Nessa nova chamada, ele fornece o contexto atualizado (a memória estratégica com tudo o que já foi feito e o resultado da última tarefa), permitindo que o PlannerAgent ajuste, corrija ou refaça o restante do plano. Isso confere ao sistema uma capacidade de adaptação e resiliência muito maior.

## 3.1 Gestão da Memória e Contexto
* Gestão da Memória Estratégica (ContextManager): Para desacoplar a gestão de memória da execução, um componente ContextManager é introduzido. Ele é um serviço obrigatório e fundamental no ciclo de execução.
* Responsabilidade: Sua única função é gerenciar a memória estratégica (de longo prazo) do fluxo de trabalho, persistida em um repositório como Redis. Após cada tarefa, ele recebe o resultado final e atualiza o estado de conhecimento global. Antes da próxima tarefa, ele fornece um contexto resumido e relevante.
* Memória em Camadas: O framework opera com duas camadas de memória:
* Estratégica (Global): Gerenciada pelo ContextManager, contém o resumo do fluxo completo.
* Tática (Local): Memória de curto prazo, contida dentro de cada sub-agente executor. Ela é volátil e existe apenas durante a execução de uma única tarefa, permitindo raciocínio interno complexo sem poluir a memória global.


**Criação e Execução de Agentes (Strategy e Factory Pattern)**

* `IAgent (Interface Strategy):` Um contrato que define o que é um agente, com um método principal execute(task). Todas as classes de agentes (ex: ResearcherAgent, WriterAgent) implementarão esta interface.
    - Contrato de Retorno Aprimorado: O método execute(task) retorna um objeto TaskResult. Para permitir uma orquestração inteligente, este objeto é mais rico do que um simples payload de dados. Ele contém:
        - status: Um enum que classifica o resultado (SUCCESS, FAILURE_RECOVERABLE, FAILURE_TERMINAL, SUCCESS_WITH_EMPTY_RESULT), permitindo ao orquestrador tomar decisões informadas (como tentar novamente ou replanejar).
        - payload: O resultado final e consolidado da tarefa.
        - metadata: Informações adicionais, como a razão da falha, para logging e depuração.
    - Isso garante o encapsulamento e simplifica a trilha de auditoria, alinhado com a filosofia de otimização para depuração humana.
`AgentFactory (Factory Pattern):` Uma classe dedicada a criar instâncias de agentes com base em um tipo ou configuração. Isso elimina a necessidade de condicionais (if/switch) no orquestrador, permitindo que novos tipos de agentes sejam adicionados ao sistema sem modificar o código existente.

**Comunicação com LLMs (Adapter Pattern)**

* ILlmApi (Interface Adapter): Um contrato que define métodos genéricos para interagir com um LLM, como generate(prompt).
* OpenAIAdapter e OpenRouterAdapter (Adapters Concretos): Classes que implementam a ILlmApi. Cada uma conterá a lógica específica (endpoints, headers, formatação do corpo da requisição) para se comunicar com sua respectiva API usando axios. O núcleo do framework dependerá apenas da abstração ILlmApi, tornando trivial a adição de novos provedores de LLM.
* Validação e Contrato de Dados (Defensive Programming): A responsabilidade do Adapter vai além da comunicação. Ele atua como uma barreira de validação. Antes de retornar uma resposta ao agente, o adapter usará uma biblioteca como Zod para validar a estrutura da resposta do LLM contra um schema esperado. Se a validação falhar (devido a uma alucinação ou mudança na API), o adapter pode tentar a chamada novamente ou lançar um erro estruturado, impedindo que dados malformados corrompam o fluxo de trabalho.

**Sistema de Ferramentas (Strategy e Adapter Pattern)**

*   **`ITool` (Interface Strategy):** Um contrato fundamental para todas as ferramentas, definindo métodos como `getName()`, `getDescription()`, `getParameterSchema()` e `execute(args)`.
*   **`ToolRegistry` (Registro):** Um serviço central onde todas as instâncias de ferramentas são registradas no início da aplicação. Os agentes não conhecem as ferramentas diretamente; eles solicitam uma ferramenta pelo nome ao `ToolRegistry`, que a fornece.
*   **Ferramentas Nativas:** Serão classes TypeScript que implementam diretamente a interface `ITool`.
*   **Suporte a Formatos Externos (MCP, etc.):** Para cada formato externo, será criado um **Adapter** (ex: `McpToolAdapter`). Essa classe implementará a *nossa* interface `ITool`, mas internamente traduzirá as chamadas para o formato esperado pela ferramenta externa. Isso permite que o sistema utilize qualquer tipo de ferramenta de forma transparente.

**Gerenciamento do Ciclo de Vida (State Pattern)**

*   O estado de uma execução (`PENDING`, `RUNNING`, `COMPLETED`, `FAILED`) será representado por classes.
*   **`IExecutionState` (Interface State):** Define as ações possíveis em um estado (ex: `run()`, `succeed()`, `fail()`).
*   **Classes de Estado Concretas (`PendingState`, `RunningState`, etc.):** Cada classe implementa a interface e contém a lógica para executar a ação e para transicionar para o próximo estado válido. Isso organiza a lógica de transição de estado de forma limpa e robusta.
*   **`StateManager`:** Gerencia o estado atual de cada execução e persiste essa informação, disponibilizando-a via endpoints HTTP.

**Flexibilização de Funcionalidades (Decorator Pattern)**

*   Para adicionar funcionalidades transversais, como logging ou cache, aos agentes sem alterar seu código, usaremos o padrão Decorator. Por exemplo, um `LoggingAgentDecorator` receberá uma instância de `IAgent` em seu construtor. Em seu método `execute`, ele registrará os logs de entrada e saída e, em seguida, chamará o método `execute` do agente original que ele "envolve".

## 4. Resumo da Aplicação dos Princípios

*   **SOLID:** A arquitetura proposta é uma aplicação direta dos cinco princípios, garantindo um sistema desacoplado, extensível e de fácil manutenção. O Princípio Aberto/Fechado é o mais proeminente: o sistema está aberto para a extensão (novos agentes, LLMs, ferramentas, estados) e fechado para modificação de seu núcleo.
*   **Lei de Deméter:** A comunicação entre camadas é estritamente controlada. A camada de entrada fala apenas com a fachada, que por sua vez fala apenas com seus colaboradores diretos (fábricas, gerenciadores), evitando que uma classe alcance profundamente a estrutura interna de outra.
*   **Obsessão por Tipos Primitivos:** Serão criados tipos e classes de domínio (ex: `ExecutionId`, `Task`, `ToolResult`) para representar conceitos, em vez de usar `string` e `object`, tornando o código mais seguro e expressivo.
*   **Classes Pequenas e Focadas:** A decomposição natural da arquitetura em estratégias, estados e adaptadores promove a criação de classes com no máximo 50 linhas e com uma única responsabilidade clara.

## Estrutura de Pastas Completa
.
├── .env                  # Variáveis de ambiente (chaves de API, etc.)
├── .eslintrc.js          # Configurações do ESLint para qualidade de código
├── package.json          # Dependências e scripts do projeto
├── tsconfig.json         # Configurações do compilador TypeScript
└── src/
    │
    ├── core/               # Lógica de negócio principal, agnóstica a frameworks e IO.
    │   │
    │   ├── agents/         # Definição e lógica dos agentes.
    │   │   ├── strategies/ # (Strategy Pattern) Implementações concretas de agentes.
    │   │   │   ├── CriticAgent.ts       # Ex: Um agente que analisa o output de outro.
    │   │   │   ├── ReActAgent.ts      # Ex: Um agente que implementa o ciclo Pensamento-Ação.
    │   │   │   └── PlannerAgent.ts    # Ex: Um agente que apenas planeja os passos.
    │   │   │
    │   │   ├── decorators/ # (Decorator Pattern) Adiciona funcionalidades aos agentes.
    │   │   │   ├── LoggingAgentDecorator.ts
    │   │   │   └── CacheAgentDecorator.ts
    │   │   │
    │   │   ├── AgentFactory.ts # (Factory Pattern) Cria instâncias de agentes.
    │   │   └── IAgent.ts       # A interface (contrato) que todo agente deve seguir.
    │   │
    │   ├── orchestration/  # Orquestração do fluxo de trabalho e tipos de domínio.
    │   │   ├── types/      # (No Primitive Obsession) Tipos de domínio próprios.
    │   │   │   ├── ExecutionId.ts
    │   │   │   ├── Task.ts
    │   │   │   └── Prompt.ts
    │   │   │
    │   │   └── AgentOrchestratorFacade.ts # (Facade Pattern) Ponto de entrada para o core.
    │   │
    │   └── state/          # Gerenciamento do ciclo de vida das execuções.
    │       ├── states/     # (State Pattern) Implementações dos diferentes estados.
    │       │   ├── PendingState.ts
    │       │   ├── RunningState.ts
    │       │   ├── CompletedState.ts
    │       │   └── FailedState.ts
    │       │
    │       ├── ContextManager.ts # Gerencia a memória estratégica (longo prazo).
    │       ├── StateManager.ts   # Gerencia o estado atual de cada execução.
    │       └── IExecutionState.ts# A interface (contrato) para as classes de estado.
    │
    ├── infrastructure/     # Implementações concretas de IO e serviços externos.
    │   │
    │   ├── adapters/       # (Adapter Pattern) Conecta o core com serviços externos.
    │   │   ├── llm/        # Adaptadores para diferentes Provedores de LLM.
    │   │   │   ├── OpenAIAdapter.ts
    │   │   │   ├── OpenRouterAdapter.ts
    │   │   │   └── ILlmApi.ts     # A interface (contrato) para qualquer LLM.
    │   │   │
    │   │   └── tools/      # Adaptadores para formatos de ferramentas externos.
    │   │       ├── McpToolAdapter.ts
    │   │       └── OpenAIFunctionAdapter.ts
    │   │
    │   ├── communication/  # Lógica de comunicação com o cliente.
    │   │   └── SSEManager.ts # Gerencia as conexões e o envio de Server-Sent Events.
    │   │
    │   └── tools/          # Implementação e gerenciamento de ferramentas.
    │       ├── registry/   # Registro central de todas as ferramentas disponíveis.
    │       │   └── ToolRegistry.ts
    │       │
    │       ├── native/     # Ferramentas "nativas" implementadas em TypeScript.
    │       │   ├── WebSearchTool.ts
    │       │   ├── FileSystemTool.ts
    │       │   └── CalculatorTool.ts
    │       │
    │       ├── schemas/    # (Opcional, mas recomendado) Schemas de validação para os inputs das tools.
    │       │   └── WebSearchSchema.ts # Ex: usando a biblioteca Zod.
    │       │
    │       ├── ITool.ts        # A interface (contrato) que toda ferramenta deve seguir.
    │       └── ToolResult.ts   # O tipo de retorno para a execução de uma ferramenta.
    │
    └── entrypoints/        # Camada de entrada da aplicação (API HTTP).
        │
        ├── controllers/    # Controladores que recebem as requisições HTTP.
        │   └── ExecutionController.ts # Ex: para criar e monitorar execuções.
        │
        ├── middleware/     # Middlewares para tratamento de erros, logs, etc.
        │   └── ErrorHandler.ts
        │
        ├── routes.ts       # Definição das rotas da API.
        └── server.ts       # Arquivo principal que inicializa o servidor HTTP e o SSE.

Com certeza! Aqui está uma seção formatada em Markdown que você pode adicionar diretamente ao seu arquivo `plan.md`. Ela resume os pontos de atenção e as sugestões de forma estruturada, mantendo o mesmo tom técnico e profissional do seu planejamento.

## 5. Pontos de Atenção e Refinamentos para a Implementação

Esta seção detalha considerações cruciais para a fase de codificação, focando em robustez, escalabilidade e manutenibilidade a longo prazo. Os pontos a seguir não alteram a arquitetura fundamental, mas a fortalecem, garantindo que a implementação seja tão sólida quanto o design.

### 5.1. Estratégia de Persistência de Estado

O `StateManager` é responsável por gerenciar o estado, mas o plano precisa especificar *como* e *onde* esse estado será persistido para garantir que as execuções sobrevivam a reinicializações do servidor e possam ser consultadas de forma duradoura.

*   **Ponto de Atenção:** Uma implementação inicial pode usar um simples mapa em memória, mas isso é volátil e inadequado para produção.
*   **Ação Recomendada:**
    1.  **Criar uma Interface de Repositório:** Definir uma interface `IStateRepository` que abstraia as operações de salvar e recuperar o estado de uma execução (ex: `save(execution)`, `findById(id)`).
    2.  **Implementações Múltiplas:** O `StateManager` dependerá dessa interface. Podemos então criar implementações concretas:
        *   `InMemoryStateRepository`: Para desenvolvimento e testes rápidos.
        *   `RedisStateRepository`: Uma implementação de alta performance para produção, ideal para gerenciar estados de curta e média duração.
        *   `DatabaseStateRepository`: Para cenários que exigem persistência de longo prazo e auditoria dos fluxos de trabalho.
    *   Isso isola completamente o núcleo da aplicação da tecnologia de armazenamento, seguindo o Princípio da Inversão de Dependência (D do SOLID).

### 5.2. Tratamento de Erros e Resiliência no Fluxo de Trabalho

O `ErrorHandler` na camada de `entrypoints` é excelente para tratar erros de requisição HTTP, mas os erros mais complexos ocorrerão dentro do fluxo de trabalho assíncrono dos agentes.

*   **Ponto de Atenção:** Uma falha na chamada de uma API de LLM ou a execução de uma ferramenta com erro não pode derrubar o sistema. O erro precisa ser capturado, registrado e o estado da execução deve ser atualizado de forma consistente.
*   **Ação Recomendada:**
    1.  **Contexto no `FailedState`:** A transição para o `FailedState` deve obrigatoriamente capturar e armazenar informações detalhadas sobre o erro (mensagem, stack trace, em qual tarefa ocorreu).
    2.  **Lógica Robusta nos Estados:** A lógica de execução dentro das classes de estado (ex: `RunningState.run()`) deve ser envolvida em blocos `try/catch` para garantir que qualquer exceção inesperada resulte em uma transição controlada para o `FailedState`.
    3.  **Estratégia de Retry:** Para falhas transientes (ex: problemas de rede com APIs externas), considere usar o **Padrão Decorator** para criar um `RetryAgentDecorator` ou `RetryToolDecorator`. Ele poderia envolver um agente ou ferramenta e tentar executar sua lógica algumas vezes antes de desistir e propagar o erro.

### 5.3. Configuração e Injeção de Dependência (DI)

À medida que o número de agentes, ferramentas e adaptadores cresce, a instanciação manual e a "ligação" entre as classes (o "wiring") podem se tornar complexas e propensas a erros.

*   **Ponto de Atenção:** A criação manual de objetos (`new OpenAIAdapter()`, `new ResearcherAgent(...)`) dentro do código de alto nível (como na Facade) cria acoplamento com implementações concretas.
*   **Ação Recomendada:**
    1.  **Adotar um Contêiner de DI:** Utilizar uma biblioteca de Injeção de Dependência como `tsyringe` (da Microsoft) ou `InversifyJS`.
    2.  **Centralizar a Configuração:** Um contêiner de DI permite registrar em um único local como as abstrações devem ser resolvidas (ex: "quando alguém pedir uma `ILlmApi`, entregue uma instância de `OpenAIAdapter`"). Isso torna a troca de implementações uma mudança em uma única linha de configuração.
    3.  **Simplificar Testes:** A DI facilita enormemente os testes unitários, permitindo substituir dependências reais (como um adaptador de API) por mocks com facilidade.

### 5.4. Gestão de Concorrência e Comunicação Assíncrona

A natureza do framework é altamente assíncrona, com múltiplos fluxos de trabalho rodando em paralelo e potencialmente múltiplos clientes escutando o mesmo fluxo via SSE.

*   **Ponto de Atenção:** É preciso garantir que as atualizações de estado sejam atômicas e que as notificações via SSE sejam enviadas de forma eficiente e sem condições de corrida.
*   **Ação Recomendada:**
    1.  **Consistência com `async/await`:** Garantir que todo o caminho de execução, da controladora até o adaptador mais profundo, utilize `async/await` e manipule `Promises` corretamente para evitar gargalos ou comportamentos inesperados.
    2.  **Design do `SSEManager`:** O `SSEManager` deve ser capaz de mapear conexões de clientes para `ExecutionId`. Quando uma atualização para um determinado ID ocorrer, ele deve iterar e enviar o evento para *todos* os clientes subscritos àquele fluxo de trabalho específico.

## 6. Segurança e Gestão de Chaves

A gestão de segredos, como chaves de API, é um pilar fundamental da segurança e da operabilidade do sistema. Uma abordagem baseada exclusivamente em `process.env` é limitada, pois requer a reinicialização da aplicação para qualquer atualização e não oferece uma estrutura organizada para diferentes ambientes. Para resolver isso, o framework adotará uma estratégia de configuração centralizada e abstraída.

*   **Ponto de Atenção:** A dependência direta de variáveis de ambiente (`process.env`) acopla o código à infraestrutura de deploy e dificulta a gestão de configurações em múltiplos ambientes (desenvolvimento, teste, produção).
*   **Ação Recomendada:**
    1.  **Adotar uma Biblioteca de Configuração:** Utilizar uma biblioteca dedicada como a `node-config`. Ela permite externalizar as configurações para uma pasta `config/` com uma hierarquia de arquivos (`default.json`, `development.json`, `production.json`), que são carregados e mesclados de acordo com a variável de ambiente `NODE_ENV`.
    2.  **Criar um Serviço de Configuração Abstraído:** Para evitar o acoplamento com a biblioteca `node-config`, será criado um `ConfigurationService` dentro da camada de `infrastructure`. Este serviço será o único ponto do sistema responsável por ler e fornecer valores de configuração.
    3.  **Injeção de Dependência:** Componentes que necessitam de segredos, como os `Adapters` de LLM (`OpenAIAdapter`, `OpenRouterAdapter`), não acessarão `process.env` ou a biblioteca `config` diretamente. Em vez disso, eles receberão o `ConfigurationService` via injeção de dependência em seu construtor e solicitarão os valores necessários (ex: `configService.getLlmApiKey('openai')`).
    4.  **Segurança no Repositório:** Arquivos contendo segredos locais ou de ambientes específicos (ex: `config/local.json`, `config/production.json`) serão obrigatoriamente incluídos no `.gitignore` para prevenir o vazamento acidental de credenciais. Em um ambiente de produção, esses arquivos serão injetados de forma segura durante o processo de deploy (CI/CD), idealmente a partir de um cofre de segredos (Secrets Manager).

Essa abordagem desacopla a lógica de negócio da gestão de configuração, melhora a segurança e simplifica drasticamente a operação e manutenção do sistema em diferentes ambientes.

## 7. Observabilidade

Para garantir que o framework seja operável, depurável e performático em produção, a observabilidade será tratada como uma capacidade fundamental da arquitetura, e não como uma funcionalidade adicionada posteriormente. A estratégia se baseia em três pilares (Logging, Métricas e Tracing) e é unificada por um conceito central: o **Contexto de Execução**.

### 7.1. O Contexto de Execução (ExecutionContext)

* Para cada fluxo de trabalho iniciado, será criado um objeto `ExecutionContext` na camada de `entrypoints`. Este objeto conterá identificadores únicos (`executionId`, `traceId`) e será propagado por toda a pilha de chamadas, do controlador à fachada, aos agentes e às ferramentas. A presença universal deste contexto é o que permitirá correlacionar qualquer evento de telemetria a uma requisição específica.

### 7.2. Pilar 1: Logging Estruturado (Para Sentry)

O objetivo é produzir logs em formato JSON, ricos em dados, que possam ser facilmente pesquisados e analisados por plataformas como o Sentry.

*   **Estratégia:**
    1.  **`LoggerService` Centralizado:** Um serviço de log será criado para abstrair a biblioteca de logging (ex: `pino`). Todo o código da aplicação utilizará este serviço em vez de `console.log`.
    2.  **Enriquecimento Automático:** Qualquer chamada ao `LoggerService` exigirá o `ExecutionContext`. O serviço irá automaticamente incluir os IDs de contexto em cada entrada de log, garantindo a correlação.
    3.  **Integração com Sentry:** O `LoggerService` será configurado para, ao registrar um erro (`logger.error()`), enviar o evento de log, já enriquecido com o contexto, para o Sentry, criando uma issue detalhada e rastreável.
    4.  **Nível de Log Configurável:** O "modo debug" será controlado através do `ConfigurationService`, permitindo alterar a verbosidade dos logs (`debug`, `info`, `warn`, `error`) por ambiente, sem modificar o código.

* Diagnóstico de Sub-Agentes: Uma função crítica do LoggerService é capturar a memória tática (local) completa de cada execução de sub-agente. Isso inclui todos os pensamentos, chamadas de ferramentas e interações com o LLM dentro daquela tarefa. Este log detalhado, correlacionado pelo ExecutionContext, é o principal artefato para a depuração humana de falhas de lógica, permitindo uma análise forense precisa do comportamento de cada agente isoladamente.

### 7.3. Pilar 2: Métricas (Para Prometheus)

As métricas fornecerão uma visão agregada da saúde e do desempenho do sistema em tempo real.

*   **Estratégia:**
    1.  **Instrumentação via Decorators:** A coleta de métricas será implementada de forma não invasiva usando o **Padrão Decorator**, que já faz parte do design do framework.
    2.  **`MetricsAgentDecorator` e `MetricsLlmAdapterDecorator`:** Serão criados decoradores que "envolvem" agentes e adaptadores. Eles medirão a duração das operações, contarão o número de execuções (sucessos e falhas) e registrarão esses dados como métricas (contadores, histogramas).
    3.  **Exposição de Endpoint:** A aplicação exporá um endpoint `/metrics` que o Prometheus poderá consultar (scrape) para coletar os dados de forma padronizada. Isso permitirá a criação de dashboards e alertas sobre a performance do sistema.

### 7.4. Pilar 3: Rastreamento Distribuído (Tracing)

O rastreamento fornecerá uma visão detalhada do ciclo de vida de uma única requisição, permitindo a identificação precisa de gargalos de performance.

*   **Estratégia:**
    1.  **Início no Middleware:** Um middleware na camada de `entrypoints` iniciará um "trace" para cada requisição, gerando o `traceId` e o `spanId` raiz no `ExecutionContext`.
    2.  **Criação de Spans com Decorators:** Os mesmos decoradores de métricas (`MetricsAgentDecorator`, etc.) serão responsáveis por criar "spans" filhos. Um span representa uma unidade de trabalho (ex: a execução de um `ResearcherAgent`). O decorator registrará o início e o fim do span, capturando sua duração e metadados.
    3.  **Exportação para Plataformas de APM:** Os dados de trace coletados serão enviados para uma plataforma de Análise de Performance de Aplicação (APM), como Sentry, Jaeger ou OpenTelemetry, onde poderão ser visualizados como gráficos de cascata (waterfall charts), tornando a análise de latência intuitiva.

## 8. Estratégia de Testes

A arquitetura desacoplada e baseada em interfaces foi projetada para ser inerentemente testável. A estratégia de testes será dividida em três níveis para garantir a qualidade e a estabilidade do código, da lógica de negócio individual à integração completa do sistema.

### 8.1. Testes Unitários

O objetivo é testar cada classe (agente, adaptador, serviço) de forma isolada para validar sua lógica interna. A Injeção de Dependência é a chave para viabilizar isso.

- Como: Para testar um agente como o ResearcherAgent, suas dependências (ILlmApi, ToolRegistry) serão substituídas por mocks (implementações falsas). Isso nos permite simular qualquer cenário — uma resposta bem-sucedida da API, uma falha de rede, uma ferramenta que não é encontrada — e verificar se o agente se comporta exatamente como esperado, sem depender de serviços externos reais.

### 8.2. Testes de Integração

O foco aqui é garantir que as diferentes unidades do sistema colaborem corretamente.

- Como: O AgentOrchestratorFacade servirá como o ponto de entrada para os testes de integração. Iniciaremos um fluxo de trabalho completo, mas utilizando implementações leves para a infraestrutura, como um InMemoryStateRepository (em vez de Redis) e mocks para as APIs de LLM. O objetivo é validar se o orquestrador gerencia corretamente o ciclo de vida, as transições de estado e a comunicação entre os agentes, conforme o plano de execução.

### 8.3. Testes End-to-End (E2E)
Esses testes simulam o comportamento de um usuário real, validando o fluxo completo da aplicação, desde a requisição HTTP até a resposta final.

- Como: Um framework de testes (como o supertest) fará chamadas HTTP reais para os entrypoints da nossa API (ex: POST /executions). O teste então verificará se a resposta HTTP está correta, se o estado da execução é persistido adequadamente e se as mensagens corretas são enviadas através do canal SSE. Esses testes rodarão em um ambiente de testes dedicado que espelha o ambiente de produção o mais próximo possível.

## Regras para codificar com IA:

- Princípios de Orientação a objetos utilizando princípios de SOLID.
- Seguir estritamente o principio de Open Closed Principe, as class devem estar abertas para extensão e fechadas para modificações.
- Utilizar quando necessário para organização de código os Padrões de projetos.
- Strategy: Exercitar o uso do polimorfismo, organizar metodos grandes em class separadas, concretas e dedicadas “ao método” usando o mesmo nome do método para que ele esteja disponivel em todas as outras class de baixo nível.
- Factory:  Resolve o problema de ter que ficar usando sempre validações com IFS, graças a este padrão de projetos conseguimos seguir o padrão de SOLID de que uma class principal nunca deve ser estendida e nunca modificada.
- Facade: Simplificar organização do código, como o fluxo de chamada de todas as service. Utilizar quando um mesmo serviço possui  vários pequenos pontos (Como várias APIs de integração, por exemplo).
- Adapter: Melhorar testes unitários e separação clara das class de Alto nível e baixo nível.
- Decorator: Facilitar a flexibilização de adição de novas funcionalidades, por exemplo encapsulando a funcionalidade anterior na nova class.
- Obsessão por tipos primitivos: Criar nosso próprio tipo e depois passar como parametro.
- Criar class com no maximo 50 linhas (Sempre que possível)
- Evitar métodos Getters e Setters.
- Adotar a prática de só ter 2 parametros por class (Ou seja, uma class como ContactInfo encapsulando todas as informações de contato e na class de Customer incorporar o parametro ContactInfo e outro seguindo a mesma lógica).
- Adotar a LEI de DEMITER: Usar class de alto nivel, ou seja, usar métodos da class vizinha e nunca usar de class com métodos de baixo nível que estão “longe” da atual.
- Utilizar padrão State: class para representar os diversos estados do projeto